.. _ftutorial-chapter:
Tutorials
=========

These tutorials build script files from scratch that, when executed, construct, run and process the results of,
an FEHM simulation. One way to enjoy this tutorial, is create a new script file and copy these commands across
as you go through them. The script can be executed at any stage within a python terminal using ``execfile('myScript.py')``
so that you can inspect the variables and objects, or just generally mess around in python.

Within a tutorial, any code commands given are assumed to be appended to the end of a single PyFEHM script for
that tutorial. A complete python script for each tutorial should have been received with PyFEHM.

.. _tutorial1:

Cube with fixed pressures/temperatures
--------------------------------------

This first tutorial describes the set up, simulation and post-processing of a simple cube model. The model contains

1. Three zones of contrasting permeability.

2. An initially homogeneous temperature and pressure distribution.

3. Fixed temperature and pressure boundary conditions.

Generation of a simple grid and construction of two contour plots of temperature and pressure are also demonstrated.

Getting started
^^^^^^^^^^^^^^^

Because this is a new script that builds a model and does some post-processing, we will need access to a few 
modules. So python can find the PyFEHM library files, first write

``import os,sys``

``sys.path.append('c:\\python\\pyfehm')``

Note, if you have created a PYTHONPATH environment variable that points to *c:\\python\\pyfehm* you can skip this step.

If your PyFEHM library files (*fdata.py, fgrid.py*, etc) are in a different location, then change the path to 
that location. If this path is contained in the PYTHONPATH environment variable, then you can skip this step.

Get access to PyFEHM grid generation, model construction and post-processing utilities.

``from`` :ref:`fdata <fdata-chapter>` ``import*``

``from`` :ref:`fpost <fpost-chapter>` ``import*``

As a first action, let us create an empty model object.

``dat =`` :class:`.fdata`\ ``()``

Define a root label for use as the default naming convention

``root = 'tut1'``

Grid generation
^^^^^^^^^^^^^^^

We will create a simple grid with 11 nodes on each side, spaced 1 m apart. First use ``np.linspace()`` to create 
a vector of these positions. The use the :meth:`.fgrid.make` command to create the grid, and the :meth:`.fgrid.plot`
command to generate a visualisation (see Figure :ref:`7.1 <tut0_fig1>`).

``x=np.linspace(0,10,11)``

``dat.``\ :attr:`~.fdata.grid`\ ``.``\ :meth:`make <.fgrid.make>`\ ``(root+'_GRID.inp',x=x,y=x,z=x)``

``dat.``\ :attr:`~.fdata.grid`\ ``.``\ :meth:`plot <.fgrid.plot>`\ ``(root+'_GRID.png',color='r',angle=[45,45])``

.. _tut0_fig1:

.. figure:: tut0_grid.png
   :scale: 100 %
   
   View of grid, as produced by :meth:`.fgrid.plot`. 
    
Zone creation
^^^^^^^^^^^^^

We need to create zones corresponding to three layers with different material properties. For zones that are bounded
by a rectangle, the easiest method for zone generation is using the :meth:`.fzone.rect` command. Below we add a zone
with index = 1, named ``'lower'`` that includes all the zones with z-coordinates between -0.1 and 3.1.

First, create the zone object with index and name.

``zn=``\ :class:`.fzone`\ ``(``\ :attr:`~.fzone.index`\ ``=1,``\ :attr:`~.fzone.name`\ ``='lower')``

Next, use the :meth:`.fzone.rect` command to define its limits.

``zn.``\ :meth:`rect <.fzone.rect>`\ ``([-0.,-0.,-0.1],[10.1,10.1,3.1])``

Finally, attach the zone to the :class:`.fdata` object.

``dat.``\ :meth:`add <.fdata.add>`\ ``(zn)``

This three step process can be simplified by calling the :meth:`.fdata.new_zone` method, which takes as input information about 
the zone (index, name, limits) and automates object creation and attachment processes. The code below is equivalent
to the three commands above

``dat.``\ :meth:`new_zone<.fdata.new_zone>`\ ``(index=1, name='lower', rect=[[-0.,-0.,-0.1], [10.1,10.1,3.1]])``

Two more zones, called 'middle' and 'upper' are created in the same way.

``dat.``\ :meth:`new_zone<.fdata.new_zone>`\ ``(index=2, name='middle', rect=[[-0.,-0.,-3.1], [10.1,10.1,6.1]])``

``dat.``\ :meth:`new_zone<.fdata.new_zone>`\ ``(index=3, name='upper', rect=[[-0.,-0.,-6.1], [10.1,10.1,10.1]])``

In the next section, we will look at assigning differing permeability properties to these zones. However, if we know that
this zone is being created for the sole purpose of assigning it some permeability, then why not do that during zone creation? 
This is achieved by passing additional material property arguments to the :meth:`~.new_zone` method. For example, to 
assign anisotropic permeability to the ``'upper'`` zone we should have written

``dat.``\ :meth:`new_zone<.fdata.new_zone>`\ ``(index=3, name='upper', rect=[[-0.,-0.,-6.1], [10.1,10.1,10.1]], permeability=[1.e-14,1.e-14,1.e-15])``

This single command will both create the zone and create a PERM macro for that zone with the specified permeability properties. If isotropic 
permeability is desired, the argument can be passed as a single float, i.e., ``permeability=1.e-14``.

Adding macros
^^^^^^^^^^^^^

Now that the zones have been established, we can begin assigning material properties, either to specific zones or to the
entire model. For example, adding rock properties to the entire model.

First, create a new ``'rock'`` :class:`.fmacro` object with a tuple of parameter name/value pairings. See Table :ref:`3.1 <fdata_table1>` for parameter names. Note,
by leaving the zone argument blank, the macro properties are assigned to all nodes in the model.

``rm=``\ :class:`.fmacro`\ ``('rock',`` :attr:`~.fmacro.param`\ ``=(('density',2500),('specific_heat',1000),('porosity',0.1)))``

Finally, attach the macro to the :class:`.fdata` object.

``dat.``\ :meth:`add <.fdata.add>`\ ``(rm)``

Note that, if ROCK properties are omitted, FEHM does not generally behave well. Therefore, if PyFEHM notes that no
global rock properties have been assigned, it will add its own default values before running the simulation (and print
a warning to to notify the user). The applies for thermal conductivity properties assigned through COND.

Now we assign different permeability properties to each of the three zones defined in the previous section.

First, create a new 'perm' :class:`.fmacro` object with a tuple of parameter name/value pairings. This time, the index of the 
first zone, 1, is assigned to the zone argument. 

``pm=``\ :class:`.fmacro`\ ``('perm',``\ :attr:`~.fmacro.zone`\ ``=1,`` :attr:`~.fmacro.param`\ ``=(('kx',1.e-15),('ky',1.e-15),('kz',1.e-16)))``

Attach the macro to the :class:`.fdata` object.

``dat.``\ :meth:`add <.fdata.add>`\ ``(pm)``

The process can be shortened by assigning permeability properties directly to the zone. In this case, PyFEHM will create the 
corresponding macro object (if it needs to, one may already exist) and attach it to the fdata structure.

``dat.``\ :attr:`~.fdata.zone`\ ``['lower'].``\ :attr:`~.fzone.permeability`\ ``=[1.e-15,1.e-15,1.e-16]``

In this variant, permeability is assigned to the variable ``kmid`` ahead of time, then called during assignment. 

``kmid=1.e-20``

``dat.``\ :attr:`~.fdata.zone`\ ``[2].``\ :attr:`~.fzone.permeability`\ ``=kmid``

Finally, permeability properties for the ``'upper'`` zone were assigned during zone creation, no further action is required.

Initial and boundary conditions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We wish to assign initial pressures and temperatures within the cube. The PRES macro is used for this

Create a new ``'pres'`` :class:`.fmacro` object with a tuple of parameter name/value pairings. The zone argument is 
left blank so that initial conditions are assigned to all nodes.

``pres=``\ :class:`.fmacro`\ ``('pres',`` :attr:`~.fmacro.param`\ ``=(('pressure',5.),('temperature',60.),('saturation',1)))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(pres)``

Again, this process is made a little simpler by assigning to the zone directly

``dat.``\ :attr:`~.fdata.zone`\ ``.``\ :attr:`~.fzone.Pi`\ ``=1.``

``dat.``\ :attr:`~.fdata.zone`\ ``.``\ :attr:`~.fzone.Ti`\ ``=60.``

We wish to set the temperature at the top and bottom boundaries to 30 and 80 degC, respectively. To do this, we will take
advantage of boundary zones automatically created by PyFEHM during grid generation. These zones have indices 999, 998,
997, 996, 995, 994 corresponding to names 'XMIN','XMAX','YMIN','YMAX','ZMIN','ZMAX'.

Create a new 'hflx' :class:`.fmacro` object with a tuple of parameter name/value pairings. Setting the 'multiplier' to a large
value will ensure that the temperature is maintained very near to 'heat_flow'. 'ZMAX' is specified in the zone
argument.
 
``hflx=``\ :class:`.fmacro`\ ``('hflx',``\ :attr:`~.fmacro.zone`\ ``='ZMAX',`` :attr:`~.fmacro.param`\ ``=(('heat_flow',30),('multiplier',1.e10)))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(hflx)``

This process can be streamlined by calling the :meth:`.fzone.fix_temperature` command from a zone associated with the
:class:`.fdata` object.

``dat.``\ :attr:`~.fdata.zone`\ ``['ZMIN'].``\ :meth:`fix_temperature <.fzone.fix_temperature>`\ ``(80)``

Now set pressures at two lateral boundaries, 'YMIN' and 'YMAX', to 4 and 6 MPa, respectively. This can be achieved using
the **FLOW** macro

``flow=``\ :class:`.fmacro`\ ``('flow',``\ :attr:`~.fmacro.zone`\ ``='YMIN',`` :attr:`~.fmacro.param`\ ``=(('rate',6.),('energy',-60.),('impedance',1.e6)))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(flow)``

Once again, this process is streamlined by calling the :meth:`.fzone.fix_pressure` command from a zone associated with the
:class:`.fdata` object.

``dat.``\ :attr:`~.fdata.zone`\ ``['YMAX'].``\ :meth:`fix_pressure <.fzone.fix_pressure>`\ ``(P=4.,T=60.)``

Running the simulation
^^^^^^^^^^^^^^^^^^^^^^

Before running the simulation, we want to specify variables to be printed out - in this case temperature and pressure - 
and request that this occurs at every time step.

``dat.``\ :attr:`~.fdata.cont`\ ``.``\ :attr:`~.fcont.variables`\ ``.append(['xyz','temperature','pressure'])``

``dat.``\ :attr:`~.fdata.cont`\ ``.``\ :attr:`~.fcont.timestep_interval`\ ``=1``

Now set the end of the simulation to be 10 days using the shortcut attribute.

``dat.``\ :attr:`~.fdata.tf`\ ``=10.``

An alternative way to set the final time is directly through the :attr:`~.fdata.time` attribute

``dat.``\ :attr:`~.fdata.time`\ ``['max_time_TIMS']=10.``

However, using the shortcut attribute :attr:`~.fdata.tf` is simpler.

Assign the root label to be used for all files created by FEHM during its execution.

``dat.``\ :attr:`~.fdata.files`\ ``.``\ :attr:`~.files.root`\ ``=root``

Run the simulation, assuming 'fehm.exe' is sitting in the current directory.

``dat.``\ :meth:`run <.fdata.run>`\ ``(root+'_INPUT.dat',exe='fehm.exe',files=['outp'])``

Visualisation
^^^^^^^^^^^^^

Finally, we produce a couple of contour plots of vertical slices through the model, to verify that pressures and temperatures 
are behaving, at least qualitatively, as we expect.

First, load in the contour information, printed to '.csv' files. Wildcards (*) are used to load multiple files.

``c=``\ :class:`.fcontour`\ ``(root+'*.csv')``

Now, call the slice plotting methods. Slice plots are shown in Figure :ref:`7.2 <tut0_fig2>`.

``c.``\ :meth:`slice_plot <.fcontour.slice_plot>`\ ``(save='Tslice.png', time=[c.times[-1], c.times[-2]], cbar=True, levels=11, slice=['x',5], variable='T', method='linear', title='temperature / degC', xlabel='y / m', ylabel='z / m')``

``c.``\ :meth:`slice_plot <.fcontour.slice_plot>`\ ``(save='Pslice.png', cbar=True, levels=np.linspace(4,6,9), slice=['x',5], variable='P', method='linear', title='pressure / MPa', xlabel='y / m', ylabel='z / m')``

.. _tut0_fig2:

.. figure:: tut0_output1.png
   :scale: 100 %
   
   Left: Contour plot of a vertical slice of temperature change during the final time step, as produced by :meth:`~.fcontour.slice_plot`. 
   Right: Contour plot of a vertical slice of pressure.
  
Five-spot injection and production
----------------------------------

This second tutorial sets up a five-spot injection/production simulation for an EGS style system. The model 
considers cold-water injection into a hot reservoir with attendant effects on stress. The model
grid is generated using built-in PyFEHM tools and is a quarter-reduced domain. 

First steps
^^^^^^^^^^^
As in the previous tutorial, we will need access to a few modules. If the PYTHONPATH environment variable is not
set, follow the instructions in tutorial 1 for adding a path to your PyFEHM library files.

Get access to PyFEHM grid generation, model construction and post-processing utilities.

``from`` :ref:`fdata <fdata-chapter>` ``import*``

``from`` :ref:`fpost <fpost-chapter>` ``import*``

As a first action, let us create an empty model object and assign the working directory to be tutorial2.

``dat =`` :class:`.fdata`\ ``(work_dir='tutorial2')``

Grid generation
^^^^^^^^^^^^^^^

Because we will model injection and production against fixed pressures, it is crucial that pressure gradients
in the vicinity of the well be fully-resolved. To this end, it will be useful to have a mesh with variable resolution:
:meth:`.fgrid.make` is useful for generating such meshes.

First, let's define some dimensions for the mesh. We want it to extend 1 km in each of the horizontal dimensions, and
span between -500 and -1500 m depth (assuming ``z = 0`` corresponds to the surface).

``X0,X1 = 0,1.e3``

``Z0,Z1 = -1.5e3,-0.5e3``

We need to know the position of the injection and production wells so the mesh can be refined in the vicinity. The
injection well is in the centre (the corner of the quarter spot) and the production well is at ``(300,300)``

``injX,injY = 0.,0.``

``proX,proY = 300.,300.``

A power-law scaled node spacing will generate closer spacing nearer the injection and production locations.

``base = 3``

``dx = proX/2.``

``x = dx**(1-base)*np.linspace(0,dx,8)**base``

``dx2 = X1 - proX``

``x2 = dx2**(1-base)*np.linspace(0,dx2,10)**base``

``X = np.sort(list(x) + list(2*dx-x)[:-1] + list(2*dx+x2)[1:])`` 

Injection and production will be hosted within an aquifer, confined above and below by a caprock. We need to define
the extent of these formations.

``Za_base = -1.1e3``

``Za_top = -800.``

As all the action will be going on in the aquifer, we will want comparatively more nodes in there.

``Z = list(np.linspace(Z0,Za_base,5)) + list(np.linspace(Za_base,Za_top,11))[1:] + list(np.linspace(Za_top,Z1,5))[1:]``

Now that the node positions have been defined, we can create the mesh using the :meth:`.fgrid.make` command.

``dat.``\ :attr:`~.fdata.grid`\ ``.``\ :meth:`make <.fgrid.make>`\ ``('quarterGrid.inp', x = X, y = X, z = Z)``

Plot a picture of the grid to check it is as expected (see Figure :ref:`7.3 <tut1_fig1>`).

``dat.``\ :attr:`~.fdata.grid`\ ``.``\ :meth:`plot <.fgrid.plot>`\ ``('quarterGrid.png', angle = [45,45], color = 'b', cutaway = [proX, proY, -1000.])``

.. _tut1_fig1:

.. figure:: tut1_gridZone.png
   :scale: 100 %
   
   Left: Cutaway view of quarterGrid.inp, as produced by :meth:`.fgrid.plot`. Right: Nodes contained in 
   ``dat.``\ :attr:`~.fdata.zone`\ ``['reservoir']``, as produced by :meth:`.fzone.rect` and illustrated by :meth:`.fzone.plot`.
    
Note that the files *quarterGrid.inp* and *quarterGrid.png* should now exist in the python working directory. Grid information
is now available within ``dat``, e.g., ``dat.``\ :attr:`~.fdata.grid`\ ``.``\ :attr:`~.fgrid.node` should be populated.
This concludes grid generation.

Zone creation
^^^^^^^^^^^^^

This problem has three defined zones, a reservoir (denoted ``res``) and upper and lower confining formations (denoted ``con``). 
For simplicity, we will not assign different material properties to the two confining layers.

Before we can assign material properties via the **PERM**, **ROCK** and **COND** macros, we need zones to which these
macros can be assigned. As these zones are rectangular, we will define them using the :meth:`~.fdata.new_zone` method, passing
it the rect argument for a bounding box defined by two corner points. First the reservoir zone.

dat.``\ :meth:`new_zone <.fdata.new_zone>`\ ``(10, name='reservoir', rect=[[X0-0.1,X0-0.1,Za_base+0.1], [X1+0.1,X1+0.1,Za_top-0.1]])``

We can plot which nodes are contained in the reservoir zone to verify we have made the correct selection (see Figure :ref:`7.1 <tut1_fig1>`).

``dat.``\ :attr:`~.fdata.zone`\ ``['reservoir'].``\ :meth:`plot <.fzone.plot>`\ ``('reservoirZone.png', color='g', angle = [30,30])``

The two confining zones are generated similarly

``dat.``\ :meth:`new_zone <.fdata.new_zone>`\ ``(20, name='confining_lower', rect=[[X0-0.1,X0-0.1,Z0-0.1], [X1+0.1,X1+0.1,Za_base+0.1]])``

``dat.``\ :meth:`new_zone <.fdata.new_zone>`\ ``(21, name='confining_upper', rect=[[X0-0.1,X0-0.1,Za_top-0.1], [X1+0.1,X1+0.1,Z1+0.1]])``

Now that the zones have been defined, we can begin assigning material properties.

Material property assignment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, declare some parameters: permeability (``perm``), density (``rho``), porosity (``phi``), 
thermal conductivity (``cond``), and specific heat (``H``).

``perm_res, perm_con = 1.e-14, 1.e-16``

``rho_res, rho_con = 2300., 2500.``

``phi_res, phi_con = 0.1, 0.01``

``cond = 2.5``

``H = 1.e3``

Now, create a new :class:`.fmacro` object to which to assign reservoir permeability. For this first time, we will 
take an unnecessary number of steps to demonstrate macro assignment

``perm=``\ :class:`.fmacro`\ ``('perm')``

``perm.``\ :attr:`~.fmacro.zone`\ ``='reservoir'``

``perm.``\ :attr:`~.fmacro.param`\ ``['kx']=perm_res``

``perm.``\ :attr:`~.fmacro.param`\ ``['ky']=perm_res``

``perm.``\ :attr:`~.fmacro.param`\ ``['kz']=perm_res``

``dat.``\ :meth:`add <.fdata.add>`\ ``(perm)``

In general, this process can be streamlined to a few or even a single step, e.g., assigning upper confining formation permeability

``perm=``\ :class:`.fmacro`\ ``('perm',``\ :attr:`~.fmacro.zone`\ ``=21,`` :attr:`~.fmacro.param`\ ``=(('kx',perm_con), ('ky',perm_con), ('kz',perm_con)))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(perm)``

Permeability can also be assigned to a zone through its :attr:`~.fzone.permeability` attribute. Behind the scenes, PyFEHM
takes care of the macro definition and zone association required by FEHM to assign this permeability.

``dat.``\ :attr:`.fdata.zone`\ ``['confining_lower'].``\ :attr:`~.fzone.permeability`\ ``=perm_con``

Similarly, rock properties are defined either through a macro object, or by zone attributes, e.g., through a macro object

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('rock',``\ :attr:`~.fmacro.zone`\ ``=dat.``\ :attr:`~.fdata.zone`\ ``['reservoir'],`` :attr:`~.fmacro.param`\ ``=(('density',rho_res), ('specific_heat',H), ('porosity',phi_res))))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('rock',``\ :attr:`~.fmacro.zone`\ ``=dat.``\ :attr:`~.fdata.zone`\ ``['confining_lower'],`` :attr:`~.fmacro.param`\ ``=(('density',rho_con), ('specific_heat',H), ('porosity',phi_con))))``

through zone attributes

``dat.``\ :attr:`.fdata.zone`\ ``['confining_upper'].``\ :attr:`~.fzone.density`\ ``=rho_con``

``dat.``\ :attr:`.fdata.zone`\ ``['confining_upper'].``\ :attr:`~.fzone.specific_heat`\ ``=H``

``dat.``\ :attr:`.fdata.zone`\ ``['confining_upper'].``\ :attr:`~.fzone.porosity`\ ``=phi_con``

Thermal conductivity (**COND**) properties are to be the same everywhere, so we will use the conductivity attribute of zone 0.

``dat.``\ :attr:`.fdata.zone`\ ``[0].``\ :attr:`~.fzone.conductivity`\ ``=cond``

Injectors and producers
^^^^^^^^^^^^^^^^^^^^^^^

The EGS problem requires both injection and production wells. To demonstrate some of FEHM's flexibility, we will
include a source that injects cold fluid at a fixed rate, and a production well that operates against a specified
production pressure.

First we require a zone for each of the production and injection wells. For the injection well, we will consider
fluid exiting the wellbore over an open-hole length, i.e., sources at multiple nodes. For the production well, we will consider a single 
feed-zone at a fixed depth, i.e., a single node sink.

First define the open hole injection nodes. The aquifer extends from -1100 to -800 m depth; we will choose a 100 m open hole
section between -1000 and -900 m. Nodes contained in this zone are well-defined by the bounding box approach of :meth:`~.fzone.rect`.

``dat.``\ :meth:`new_zone <.fdata.new_zone>`\ ``(30, name='injection', rect=[[injX-0.1,injY-0.1,-1000.1],[injX+0.1,injY+0.1,-899.9]])``

Note that, in general, it is good to enlarge the bounding box by some nominal amount (in this case, 0.1 m) to insure
that the nodes are in fact 'bounded' by the box. 

Now to define the production feed-zone; let's suppose that it is at the known depth of -950 m.
As we want to find the node closest to this location, we will use the :meth:`~.fgrid.node_nearest_point` command.

``pro_node=dat.``\ :attr:`~.fdata.grid`\ ``.``\ :meth:`node_nearest_point <.fgrid.node_nearest_point>`\ ``([proX,proY,-950])``

``dat.``\ :meth:`new_zone <.fdata.new_zone>`\ ``(40, 'production', nodelist=pro_node)``

Now that the zones have been defined, we will assign mass flow generators via the **FLOW** and **BOUN** macros. First the 
production well, which is simply production against a fixed pressure, let's say 6 MPa. We will use the :class:`.fmacro`\ ``('flow')``
object with a non-zero impedance parameter indicating production against a fixed pressure.

``flow=``\ :class:`.fmacro`\ ``('flow',``\ :attr:`~.fmacro.zone`\ ``='production',`` :attr:`~.fmacro.param`\ ``=(('rate',6), ('energy',30), ('impedance',1.)))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(flow)``

There are multiple nodes in the injection zone, but we wish to specify a single mass injection rate. The **BOUN** macro
is useful for distributing a fixed source across multiple nodes. Recall that, in contrast to **FLOW**, **BOUN** has its 
own macro object, :class:`.fboun`.

``injRate=4.``

``injTemp=60.``

``boun=``\ :class:`.fboun`\ ``(``\ :attr:`~.fboun.zone`\ ``=['injection'],`` :attr:`~.fboun.times`\ ``=[0,1e10],`` :attr:`~.fboun.variable`\ ``=[['dsw',-injRate,-injRate], ['ft',injTemp,injTemp]]])``

``dat.``\ :meth:`add <.fdata.add>`\ ``(boun)``

This creates a source of 60degC water, injecting at a rate of 2 kg/s, distributed evenly across all nodes in the 'injection' zone ('dsw' = distributed source water).
By assigning a large value in ``boun.``\ :attr:`~.fboun.times` we ensure that the source will continue to operate for the entire
simulation.

Initial conditions
^^^^^^^^^^^^^^^^^^

Before running the simulation we need to set up initial conditions for temperature and pressure. For simplicity, we will
assume that gradients in both are linear from the surface, although more complex configurations can of course be
accommodated.

For the temperature field, we will use the **GRAD** macro, with a 70degC / km temperature gradient, 25degC surface temperature 
corresponding to ``z = 0``. Again, by omitting the zone parameter when creating the :class:`.fmacro` object, the macro will
automatically be applied to all nodes. More complex initial temperature distributions can be created by passing measured
temperature profile data to the :meth:`~.fdata.temperature_gradient` command.

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('grad',`` :attr:`~.fmacro.param`\ ``=(('reference_coord',0.), ('direction',3), ('variable',2), ('reference_value',25.), ('gradient',-0.06))))``

For the pressure distribution, we will assume this is initially hydrostatic, although FEHM will recalculate pressures based on the
temperature dependent fluid density. Specifying the pressure distribution requires two macros: (i) a **GRAD** for the pressure gradient, and (ii)
a fixed pressure, implemented by the :meth:`fix_pressure <.fzone.fix_pressure>`\ ``()`` method, at the top surface representing the submerged upper surface of the model. First add
the pressure gradient

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('grad',`` :attr:`~.fmacro.param`\ ``=(('reference_coord',0.), ('direction',3), ('variable',1), ('reference_value',0.1), ('gradient',-9.81*1e3/1e6))))``

Upon grid initialisation, PyFEHM already created the zone for the top surface, assigned the key ``'ZMAX'``. We use the 
:meth:`fix_pressure <.fzone.fix_pressure>`\ ``()`` method to assign surface pressure conditions

``dat.``\ :attr:`~.fdata.zone`\ ``['ZMAX'].``\ :meth:`fix_pressure <.fzone.fix_pressure>`\ ``(P=0.1+Z1*-9.81*1e3/1e6,T=25.+Z1*-0.06)``

Setting up stresses
^^^^^^^^^^^^^^^^^^^

Set up for a stress solution in FEHM requires (i) specification of material parameters relevant to mechanical deformation,
e.g., Young's modulus, thermal expansion coefficient, (ii) boundary conditions, either displacement or force, and (iii) optionally
an initial stress state or (iv) a stress-permeability model. In this example we will include the first three features.

Initial stress states are calculated and loaded in via FEHM's restart or INCON file. This file also contains information on 
the restart of temperature and pressure; therefore, to perform a stress restart we first require the temperature and pressure 
restart information. The easiest way to obtain this is to run one time step of the model (without the stress solution) and request
it to output a restart file at the end of the time step. We do this by setting the ``dat.``\ :attr:`~.fdata.files`\ ``.``\ :attr:`~.files.rsto`
attribute to the name of the restart file.

``dat.``\ :attr:`~.fdata.dtn`\ ``=1``

``dat.``\ :attr:`~.fdata.files`\ ``.``\ :attr:`~.files.rsto`\ ``='EGS_INCON.ini'``

``dat.``\ :meth:`run <.fdata.run>`\ ``('EGS_flow_INPUT.dat')``

Note that, because we have not specified an FEHM executable in the *exe* argument of :meth:`run <.fdata.run>`,
PyFEHM will automatically search for *fehm.exe* in the current working directory.

Now that the model has run a single time step, the output restart file (containing only temperature and pressure data) can be
read as an initial conditions file (:class:`.fincon`).

``dat.``\ :attr:`~.fdata.incon`\ ``.``\ :meth:`read <.fincon.read>`\ ``('EGS_INCON.ini')``

Vertical gradients in the three principal stresses can be calculated using the :meth:`.fincon.stressgrad` command. In this case
we will request that PyFEHM calculates the vertical load by integrating the variable density information supplied in 
:class:`.fmacro`\ ``['rock']``, and the horizontal stresses as fractions of the vertical.

``dat.``\ :attr:`~.fdata.incon`\ ``.``\ :meth:`stressgrad <.fincon.stressgrad>`\ ``(xgrad=0.6, ygrad=0.8, zgrad=2500*abs(Z1)*9.81/1e6, calculate_vertical=True, vertical_fraction=True)``

Now to turn the stress solution on and assign material parameters to the various zones in the model. We will assign
different deformation parameters (**ELASTIC**) to the reservoir and confining units, but assume that stress-flow coupling 
parameters (**BIOT**) are the same throughout. These are material properties and thus can be assigned using appropriate zone
attributes

``dat.``\ :attr:`~.fdata.strs`\ ``.``\ :meth:`on <.fstrs.on>`\ ``()``

``E_res,E_con = 2e3,2e4``

``nu_res,nu_con = 0.15,0.35``

``dat.``\ :attr:`.fdata.zone`\ ``['reservoir'].``\ :attr:`~.fzone.youngs_modulus`\ ``=E_res``

``dat.``\ :attr:`.fdata.zone`\ ``['confining_lower'].``\ :attr:`~.fzone.youngs_modulus`\ ``=E_con``

``dat.``\ :attr:`.fdata.zone`\ ``['confining_upper'].``\ :attr:`~.fzone.youngs_modulus`\ ``=E_con``

``dat.``\ :attr:`.fdata.zone`\ ``['reservoir'].``\ :attr:`~.fzone.poissons_ratio`\ ``=nu_res``

``dat.``\ :attr:`.fdata.zone`\ ``['confining_lower'].``\ :attr:`~.fzone.poissons_ratio`\ ``=nu_con``

``dat.``\ :attr:`.fdata.zone`\ ``['confining_upper'].``\ :attr:`~.fzone.poissons_ratio`\ ``=nu_con``

``dat.``\ :attr:`.fdata.zone`\ ``[0].``\ :attr:`~.fzone.thermal_expansion`\ ``=3.e-5``

``dat.``\ :attr:`.fdata.zone`\ ``[0].``\ :attr:`~.fzone.pressure_coupling`\ ``=1.``

Because we have prescribed the initial stress state, boundary conditions and body forces to not need to reflect
gravitational or tectonic loading. For this reason, we should turn body force calculations off, and assign fixed displacement
boundary conditions to prevent model drift (roller boundary conditions on the ``x=0``, ``y=0`` and ``z=0`` planes). Note
that these zones already exist, automatically created by PyFEHM with the names ``'XMIN'``, ``'YMIN'`` and ``'ZMIN'``. Furthermore,
it is advisable when defining boundary conditions to pass the ``write_one_macro=True`` argument - this improves stability of the
stress solution.

``dat.``\ :attr:`~.fdata.strs`\ ``.``\ :attr:`~.fstrs.fem`\ ``=1.``

``dat.``\ :attr:`~.fdata.strs`\ ``.``\ :attr:`~.fstrs.bodyforce`\ ``=0.``

``dat.``\ :attr:`~.fdata.sol`\ ``['element_integration_INTG']=-1``

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('stressboun',`` :attr:`~.fmacro.zone`\ ``=60,`` :attr:`~.fmacro.subtype`\ ``='fixed',`` :attr:`~.fmacro.param`\ ``=(('direction',1), ('value',0))))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('stressboun',`` :attr:`~.fmacro.zone`\ ``=61,`` :attr:`~.fmacro.subtype`\ ``='fixed',`` :attr:`~.fmacro.param`\ ``=(('direction',2), ('value',0))))``

``dat.``\ :meth:`add <.fdata.add>`\ ``(``\ :class:`.fmacro`\ ``('stressboun',`` :attr:`~.fmacro.zone`\ ``=62,`` :attr:`~.fmacro.subtype`\ ``='fixed',`` :attr:`~.fmacro.param`\ ``=(('direction',3), ('value',0))))``

Note that, for a well-behaved model I have set the ``dat.``\ :attr:`~.fdata.strs`\ ``.``\ :attr:`~.fstrs.fem` and
``dat.``\ :attr:`~.fdata.sol`\ ``['element_integration_INTG']`` attributes to particular values - mess with these
at your peril.

Running the model
^^^^^^^^^^^^^^^^^

Before running the final model, we need to tell FEHM to output variable information at particular locations and times. 
This is done through the ``dat.``\ :attr:`~.fdata.cont` and ``dat.``\ :attr:`~.fdata.hist` attributes.

First, to the contour output, we will request information on pressure, temperature, stress and other variables at the end of the simulation, 
and every six months.

``dat.``\ :attr:`~.fdata.cont`\ ``.``\ :attr:`~.fcont.variables`\ ``.append(['xyz', 'pressure', 'liquid', 'temperature', 'stress', 'displacement', 'permeability'])``

``dat.``\ :attr:`~.fdata.cont`\ ``.``\ :attr:`~.fcont.format`\ ``='surf'``

``dat.``\ :attr:`~.fdata.cont`\ ``.``\ :attr:`~.fcont.timestep_interval`\ ``=1000.``

``dat.``\ :attr:`~.fdata.cont`\ ``.``\ :attr:`~.fcont.time_interval`\ ``=365.25/2.``

For history output, we will request information on temperature, pressure and flow, at each time step for the 
single production node and the total injection zone.

``dat.``\ :attr:`~.fdata.hist`\ ``.``\ :attr:`~.fhist.variables`\ ``.append(['temperature', 'pressure', 'flow', 'zfl'])``

``dat.``\ :attr:`~.fdata.hist`\ ``.``\ :attr:`~.fhist.format`\ ``='surf'``

``dat.``\ :attr:`~.fdata.hist`\ ``.``\ :attr:`~.fhist.nodeflux`\ ``.append(dat.zone['production'].nodelist[0])``

``dat.``\ :attr:`~.fdata.hist`\ ``.``\ :attr:`~.fhist.zoneflux`\ ``.append(dat.zone['injection'])``

Finally, we need to change the time step count (as this was originally set to 1), and request the simulation to 
continue for 10 years with a maximum time step of 1 year. Shortcut attributes are utilised for these three requests.

``dat.``\ :attr:`~.fdata.dtn`\ ``=1000``

``dat.``\ :attr:`~.fdata.tf`\ ``=365.25*10.``

``dat.``\ :attr:`~.fdata.dtmax`\ ``=365.25``

Now to run the simulation. Post-processing of the simulation output will be detailed in the next section.

``dat.``\ :attr:`~.fdata.files`\ ``.``\ :attr:`~.files.root`\ ``='EGS'``

``dat.``\ :meth:`run <.fdata.run>`\ ``('EGS_stress_INPUT.dat',files=['hist','outp','check'])``

Post-processing
^^^^^^^^^^^^^^^

Let's first produce some slice plots of the final temperature, pressure and stress distributions. Contour output
is read in by the :class:`.fcontour` class. Although we have only requested a single contour output file (at the 
end of the simulation), the code below is general enough to search through *all* contour output, but take only the
latest generated file (presumably corresponding to the end of the simulation).

``cont=``\ :class:`.fcontour`\ ``(dat.``\ :attr:`~.fdata.files`\ ``.``\ :attr:`~.files.root`\ ``+'*.csv',latest=True)``

There are several options for generating data plots, and we will demonstrate some of PyFEHM's plotting capabilities 
here. 

1. A horizontal slice plot of temperature (see Figure :ref:`7.4 <tut1_fig2>`).

  ``cont.``\ :meth:`slice_plot <.fcontour.slice_plot>`\ ``(save='temperature_slice.png', cbar=True, levels = 10, slice = ['z',-1000], divisions=[100,100], variable='T', xlims=[0,500], ylims=[0,500], title='final temperature distribution')``

2. A profile plot of pressure between the injection and production wells (see Figure :ref:`7.4 <tut1_fig2>`).

  ``cont.``\ :meth:`profile_plot <.fcontour.profile_plot>`\ ``(save='pressure_profile.png', profile=np.array([[0,0,-1000], [400,400,-1000]]), variable='P', ylabel='pressure / MPa', title='pressure with distance from injector', color='g', marker='o--', method='linear')``

3. A vertical profile plot of stress at ``x,y = [600,600]`` (see Figure :ref:`7.5 <tut1_fig3>`).

  ``cont.``\ :meth:`profile_plot <.fcontour.profile_plot>`\ ``(save='stress_profile.png', profile=np.array([[600,600,-500], [600,600,-1500]]), variable='strs_xx', xlabel='depth / m', ylabel='pressure / MPa', title='horizontal stress with depth', color='k', marker='-', method='linear', elevationPlot=True)``

4. A cutway plot of temperature (see Figure :ref:`7.5 <tut1_fig3>`).

  ``cont.``\ :meth:`cutaway_plot <.fcontour.cutaway_plot>`\ ``(variable='T', save='temperature_cutaway.png', xlims=[0,400], ylims=[0,400], zlims=[-1000,-800], cbar=True, levels=np.linspace(60,90,11), grid_lines='k:', title='temperature contours / $^o$C')``

Now let's look at some of the time-series plotting capability. First we need to read in the history output for the flow
data at the production well. 

``hist=``\ :class:`.fhistory`\ ``(dat.``\ :attr:`~.fdata.files`\ ``.``\ :attr:`~.files.root`\ ``+'_flow_.his.dat')``

Now produce a time series plot of the production data (see Figure :ref:`7.6 <tut1_fig4>`).

``hist.``\ :meth:`time_plot <.fcontour.time_plot>`\ ``(variable='flow', save='extraction_plot.png', node=hist.nodes[0], scale_t=1./365.25, xlabel='time / years', ylabel='flow kg s$^{-1}$')``

.. _tut1_fig2:

.. figure:: tut1_output1.png
   :scale: 100 %
   
   Left: Slice plot of final temperature distribution at ``z=-1000``, as produced by :meth:`~.fcontour.slice_plot`. 
   Right: Horizontal profile plot of pressure with distance from the injector, as produced by :meth:`~.fcontour.profile_plot`.

.. _tut1_fig3:

.. figure:: tut1_output2.png
   :scale: 100 %
   
   Left: Vertical profile plot of horizontal stress, as produced by :meth:`~.fcontour.profile_plot`. 
   Right: Cutaway plot of temperature, as produced by :meth:`~.fcontour.cutaway_plot`.
  
.. _tut1_fig4:

.. figure:: tut1_output3.png
   :scale: 50 %
   
   Time series plot of production flow rate, as produced by :meth:`~.fhistory.time_plot`. 

Multiprocessing and batch job submission
----------------------------------------

Having constructed and performed an FEHM simulation, often it is necessary to rerun the model for different parameter values.
This could be for either calibration or parameter sensitivity purposes. In these situations, the models can be run as batches - 
with no requirement for information transfer between simulations, they can be run asynchronously in parallel.

.. _multiprocessing: http://docs.python.org/2/library/multiprocessing.html

Using Python's multiprocessing_ module, we can generalise a script that creates, runs and postprocesses an FEHM simulation
for one specific parameter set so as to distribute multiple simulations across a specified number of cores. As an example, we shall
extend the first tutorial (Section :ref:`7.1 <tutorial1>`).

Setting up a batch of simulations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, import the multiprocessing module.

``import multiprocessing``

We will use indices to keep track of models. In this case, we will run the model four times with different parameters
and so require indices 1 through 4, given by the ``range()`` command. Additionally, we will choose to distribute these 
jobs to two or our machine's processors.

``models = range(1,5)``

``processors = 2``

Now we need to define the parameter sets for each of the four simulations. In this case, we are looking at two different
permeabilities for the centre layer, and two different temperatures for the boundary condition at the base of the model. 
Each parameter set is a list, and all parameter sets are contained in a single list, i.e., a nested list structure. The 
formatting used below is simply a visual aide to keep track of simulations.

``params = [``

``#[kmid,Tbase], 		# legend``

``[1.e-20,80], 			# 1``

``[1.e-20,120], 			# 2``

``[1.e-16,80], 			# 3``

``[1.e-16,120], 			# 4``

``]``

Generalising to a function
^^^^^^^^^^^^^^^^^^^^^^^^^^

In tutorial 1 (Section :ref:`7.1 <tutorial1>`), we wrote a script to construct, run and post-process a simple
FEHM simulation. As a first step, this script must be generalised as a callable function - this is relatively easy.

The corresponding function is defined by writing

``def simulation(j,param):``

and then indenting the rest of the script below this line (excluding import commands which should remain outside the function call). 
The name of the function is ``simulation`` and it receives two input arguments: ``j``, an integer index indicating which
model we are running, and ``param`` a list of parameters to be assigned within the function call. For example, in the case
describe here ``param`` might contain ``[1.e-20,120]``, i.e., the second parameter set in the list of all parameter sets,
``params``, defined in the previous section.

Parameters as function arguments
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In tutorial 1, the parameters to be varied are defined explicitly in the script with the lines

``kmid=1.e-20``

``dat.``\ :attr:`~.fdata.zone`\ ``['ZMIN'].``\ :meth:`fix_temperature <.fzone.fix_temperature>`\ ``(80)``

These lines need to be altered to reflect the general parameters supplied as the argument param. First, we will unpack
the list ``param`` into separate variables by writing

``kmid, Tbase = param``

or equivalently

``kmid=param[0]``

``Tbase=param[1]``

Now, ``kmid`` is clearly defined, and we can simply delete the line reading 

``kmid=1.e=20``

If left in, this would override the value of ``kmid`` passed as an argument to ``simulation``.

In the case of ``Tbase``, we need to replace the argument of :meth:`fix_temperature <.fzone.fix_temperature>`\ ``
so that it reads 

``dat.``\ :attr:`~.fdata.zone`\ ``['ZMIN'].``\ :meth:`fix_temperature <.fzone.fix_temperature>`\ ``(Tbase)``

Assigning the simulation a target directory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As we are performing four simulations, for the sake of tidiness, it makes sense that all files pertaining 
to a simulation should be placed in a separate simulation directory. This is necessary, as calling fehm.exe
multiple times simultaneously in the same directory can lead to sharing issues.

Performing simulations in target directories is relatively simple with PyFEHM. The first step is to generate
a different root label for each simulation, using the model index (passed to ``simulation`` as the argument ``j``)
to distinguish between each. We replace

``root = 'tut1'``

with

``root = 'tut3_'+str(j)``

which will yield root labels 'tut3_1', 'tut3_2', 'tut3_3' and 'tut3_4' for the four simulations.

Second, when the :class:`.fdata` object is created, we pass the root label to the input argument ``work_dir``.

``dat =`` :class:`.fdata`\ ``(work_dir=root)``

This tells PyFEHM that all grid, input, incon and output files should be created in the new folder ``root`` inside
the current work directory. Furthermore, the simulation itself is performed inside ``root`` and not the current 
directory.

Two additional changes are required in the post-processing section so that the correct files are targeted. These are 

``c=``\ :class:`.fcontour`\ ``(root+'\\*.csv',latest=True)``

and

``c.``\ :meth:`slice_plot <.fcontour.slice_plot>`\ ``(save=root+'\\Tslice.png', cbar=True, levels=11, slice=['x',5], variable='T', method='linear', title='temperature / degC', xlabel='y / m', ylabel='z / m')``

``c.``\ :meth:`slice_plot <.fcontour.slice_plot>`\ ``(save=root+'\\Pslice.png', cbar=True, levels=np.linspace(4,6,9), slice=['x',5], variable='P', method='linear', title='pressure / MPa', xlabel='y / m', ylabel='z / m')``

Assembling the processing pool and distributing the simulations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, we write a simple function that, for a given model index, executes the simulation function (``simulation``) one
time, passing it the correct input arguments. The name of this function will be ``execute()`` and its definition
is given below.

``def execute(j):``

  ``simulation(j,params[j-1])``

Now there are simply two commands to submit the batch job. The first, ``multiprocessing.Pool`` assembles a pool of
available processors that will be used to run simulations. As a simulation is complete, its processor is returned to the pool
and is then available to run a new simulation. The second command maps the simulation function, as accessed through 
``execution()`` with the set of models to be run ``models``, defined in the first section. These two tasks are coded below

``if __name__ == '__main__':``	

  ``p=multiprocessing.Pool(processes = processors)``

  ``p.map(execute,models)``

The ``if`` conditional preceding these commands is very important. Omitting this can lead to an infinite loop that spawns a new
python process each time - this can rapidly overwhelm the system and is generally counterproductive.

Basic operation of the parallel batch script
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When this modified script is executed, the following actions are executed

1. A pool of two available processors is assembled (``multiprocessing.Pool``).

2. Four indices (1,2,3, and 4) corresponding to four models (``params[0]``, ``params[1]``, etc.) are submitted to the
   function ``execute``. Because there are two available processors, ``execute`` proceeds with ``j=1`` on the
   first and ``j=2`` on the second.

3. ``execute`` passes both ``j`` and the parameter set ``params[j-1]`` to the function ``simulation()``. This function

	a. Creates a new directory numbered by ``j``.
	
	b. Creates a grid in that directory.
	
	c. Constructs and runs an FEHM model with the specific parameters in that directory.
	
	d. Post-processes output results in that directory.
	
4. When ``simulation`` and ``execution`` complete, the processor is returned to the pool. Model indices ``j=3`` and ``j=4`` are still waiting
   and will take these returned processors as they become available, executing step 3 themselves.

5. When all model indices have been input to and returned by ``execute``, the batch simulation is complete.

Dynamic simulation monitoring
-----------------------------

In some instances, the final simulation time for a model is specified as some arbitrarily large value. This is to
ensure that the model doesn't finish before the behaviour we are trying to model has. However, if we could observe
the simulation as it proceeded, we could monitor for an arbitrary finish criterion and terminate the process when it 
is satisfied. 

In this tutorial, we will demonstrate how to specify an arbitrary kill condition for a simulation - in this case, 
when the temperature at a particular node drops below a given value.

As in the previous tutorial, we will use as a basis the model developed in tutorial 1.

Defining a kill condition
^^^^^^^^^^^^^^^^^^^^^^^^^

First, the simulation time is doubled to 20 days.

``dat.``\ :attr:`~.fdata.tf`\ ``=20.``

The kill condition is defined as a function with particular input and return conditions. The function must accept
a single input, an :class:`.fdata` object, and return True or False depending on whether the condition has been satisfied.

This function is passed to the ``until`` argument in the :meth:`run <.fdata.run>`\ ``()`` method when the simulation is
executed. In operation, the function is passed the :class:`.fdata` instance from which :meth:`run <.fdata.run>`\ ``()``
is called. PyFEHM monitors for output files containing information for a restart simulation that are 
periodically written by FEHM; these are parsed and the information made available at the nodal level. For example, nodal temperatures
are available through the :attr:`.fnode.T` attribute inside the function.

First define the function

``def kill_condition(dat):``

We want to set a kill condition when the node at position [7,7,9] has a temperature less than 50degC. First we need to 
locate that node 

  ``nd=dat.``\ :attr:`~.fdata.grid`\ ``.``\ :meth:`node_nearest_point <.fgrid.node_nearest_point>`\ ``([7.,7.,9.])``

This node's state attributes are updated at each time step during the simulation. Thus, all that is required is for us to test
the kill condition

  ``return nd.``\ :attr:`~.fnode.T`\ ``<50``
  
Now run the simulation with the modified :meth:`run <.fdata.run>`\ ``()`` method

``dat.``\ :meth:`run <.fdata.run>`\ ``(root+'_INPUT.dat',until=kill_condition)``

This simulation now finishes after 5 time steps or approximately 13 days, instead of the 20 days specified as the end
of the simulation.





